{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project Description \u00b6 ResQ is an online live queue tool for use by the staff of the UWA STUDYSmarter program. The purpose of it is to provide a robust and convinient way of managing a queue, as well as saving the data for each entry into the queue to allow for some simple data analytics. Authors \u00b6 Jordan Hartley Liam Hovell Frinze Lapuz Alex Hoffman Alex Mai Jake Yendell","title":"Overview"},{"location":"#project-description","text":"ResQ is an online live queue tool for use by the staff of the UWA STUDYSmarter program. The purpose of it is to provide a robust and convinient way of managing a queue, as well as saving the data for each entry into the queue to allow for some simple data analytics.","title":"Project Description"},{"location":"#authors","text":"Jordan Hartley Liam Hovell Frinze Lapuz Alex Hoffman Alex Mai Jake Yendell","title":"Authors"},{"location":"developer/","text":"Technical Documentation for Developer \u00b6 Application \u00b6 The website is run using a flask server. Flask is a micro framework for the backend of the website. Jinja is used inside the HTML so the display can adapt to server data as well as for running loops. Users and test attempts are saved inside a SQLite database. The username, password, and scores of the user are saved so progress can be encouraged. Development Workflow \u00b6 This project uses docker to orchestrate multiple services. Make sure to install docker, see here for documentation. Once you have it installed do the following: Environment Variables: Create the .env file \u00b6 There is a file called template.env . This contains all the configurations for the entire application for database, flask app, and pgadmin. Copy this to .env (you have to create this file). Run the Docker-Compose \u00b6 Run the following command 1 docker-compose up This one command will build all the containers. Most notably this will create the Flask Application with pip installation, and database migration to PostgreSQL. Rebuilding containers If you do need to build containers, run the following: 1 docker-compose up --build Services that are running \u00b6 There are a couple of services that are running Services URL PostgreSQL Database http://localhost:5432 PgAdmin (PostgreSQL GUI) http://localhost:8002 ReSQ Flask App http://localhost:5000 MkDocs Documentation http://localhost:8001 Going inside the container / Remote Code Execution \u00b6 Most likely you will be developing inside this container such as doing pip installation and other commands. You can do remote code execution to the container using the following command 1 docker exec -it resq_app bash This will allow you to connect to the container and do whatever command that pleases you.","title":"Overview"},{"location":"developer/#technical-documentation-for-developer","text":"","title":"Technical Documentation for Developer"},{"location":"developer/#application","text":"The website is run using a flask server. Flask is a micro framework for the backend of the website. Jinja is used inside the HTML so the display can adapt to server data as well as for running loops. Users and test attempts are saved inside a SQLite database. The username, password, and scores of the user are saved so progress can be encouraged.","title":"Application"},{"location":"developer/#development-workflow","text":"This project uses docker to orchestrate multiple services. Make sure to install docker, see here for documentation. Once you have it installed do the following:","title":"Development Workflow"},{"location":"developer/#environment-variables-create-the-env-file","text":"There is a file called template.env . This contains all the configurations for the entire application for database, flask app, and pgadmin. Copy this to .env (you have to create this file).","title":"Environment Variables: Create the .env file"},{"location":"developer/#run-the-docker-compose","text":"Run the following command 1 docker-compose up This one command will build all the containers. Most notably this will create the Flask Application with pip installation, and database migration to PostgreSQL. Rebuilding containers If you do need to build containers, run the following: 1 docker-compose up --build","title":"Run the Docker-Compose"},{"location":"developer/#services-that-are-running","text":"There are a couple of services that are running Services URL PostgreSQL Database http://localhost:5432 PgAdmin (PostgreSQL GUI) http://localhost:8002 ReSQ Flask App http://localhost:5000 MkDocs Documentation http://localhost:8001","title":"Services that are running"},{"location":"developer/#going-inside-the-container-remote-code-execution","text":"Most likely you will be developing inside this container such as doing pip installation and other commands. You can do remote code execution to the container using the following command 1 docker exec -it resq_app bash This will allow you to connect to the container and do whatever command that pleases you.","title":"Going inside the container / Remote Code Execution"},{"location":"developer/automated_testing/","text":"Automated Testing \u00b6 Unit Testing \u00b6 Unit testing is created using Pytest . Refer documentation closely to Pytest-Flask for this project. conftest conftest.py are a special file for pytest that is automatically loaded by pytest and typically contans fixtures and other setup code. Docker Container Running Make sure that you are running the docker container before doing any testing. How to run unit tests? \u00b6 Use the docker remote code execution 1 docker exec -it resq_app pytest or if you want to generate the coverage data 1 docker exec -it resq_app coverage run --source = \".\" --rcfile = .coveragerc -m pytest Coverage File This will produce a file called .coverage that contains the records and can be converted to reports. Allure Results Whenever you are running this tests, it will produce a folder called test_results that will contain results of the test. Refer below for more information about Allure. How to get coverage report? \u00b6 If you've run the tests using the above command and have .coverage file, you can generate the reports in multiple ways. More information in here . 1 coverate report -m will print the coverage report in the terminal. 1 coverage html for the html report. What is .coveragerc file? This file contains the configurations for the coverage testing. Unit Testing in Pipelines \u00b6 This was part of #12 , but was cut out of scope. Some artefacts of the code can be seen here. One particular one is the docker runtime.sh that can accomodate a APP_ENV=UNIT_TESTS to only run unit tests inside the docker. Allure Report Generator \u00b6 Allure Testing report is used as a tool to generate test report. More information here https://docs.qameta.io/allure/ This repo has a file called send_and_generate.py . It is a simple script that sends a test report to Allure and generates a report. This is currently integrated with the UWA System Health Lab Allure Setup . Documentation can be seen here . Integration Testing \u00b6 The integration tests are created with Cypress . This integration testing allows us to create frontend tests and obtain video or screenshots that can improve the quality of the test. Running Tests Via Cypress IDE \u00b6 Installment Prerequisite Install Nodejs and NPM (should be automatically installed with Nodejs). Go to integration_tests folder and do npm install . That is going to install your package.json packages. In one terminal, run docker-compose up for running application. Without closing terminal opened in 1), open a new terminal and go to /integration_tests and: Run yarn run cypress:open or Run npm run cypress:open Note that by using this, the Cypress IDE will be running outside the docker container. Configuring Cypress \u00b6 Cypress configuration can be adjusted in the cypress.json file. If you want to define global varibles, this is the place to do it. Global variables can be used in the code with Cypress.env('VAR') . More information can be seen in the official docs https://docs.cypress.io/guides/references/configuration Writing Tests \u00b6 There are 2 ways to create tests: By writing code tests, see Writing Test Or by using the Cypress Studio Cypress studio makes it easy to create test by recording the user action through the Cypress IDE. Upon action of the user, Cypress studio writes codes in the tests which could be adjusted later for flexibility. To use Cypress Studio Test Creation Firstly, you need a test suite ends with .spec.js in the integration_tests/cypress/integration folder (either newly created from a test template or existing test). Test Template 1 2 3 4 5 6 7 8 9 describe ( 'Test Suite' , () => { beforeEach (() => { // Setup Scripts Here }) it ( 'Test Name' , () => { // Extend test with Cypress Studio }) }) Select a test suite in the Cypress IDE to extend Hover on the test, and click the \"magic wand\" icon near the test Interact with the Cypress Web interface as if you are the test runner Save the test when you are done Modify the tests created by Cypress IDE as you need Magic Wand Icon Test files and directory organization \u00b6 All test specs are located in integration_tests/cypress/integration . We recomend follow an structure by feature. In integration_tests/cypress/support you can write reusable pieces of code for execute in all your tests with commands . Test Results \u00b6 Results after tests suite finished are stored in the following folders: integration_tests/cypress/screenshots : Screenshots generated by cypress integration_tests/cypress/videos : Videos generated by cypress integration_tests/cypress/results : Allure formatted results Allure Integration with Cypress \u00b6 Cypress test runner has installed an allure plugin which is used to generate tests results with allure format. Documentation","title":"Automated Testing"},{"location":"developer/automated_testing/#automated-testing","text":"","title":"Automated Testing"},{"location":"developer/automated_testing/#unit-testing","text":"Unit testing is created using Pytest . Refer documentation closely to Pytest-Flask for this project. conftest conftest.py are a special file for pytest that is automatically loaded by pytest and typically contans fixtures and other setup code. Docker Container Running Make sure that you are running the docker container before doing any testing.","title":"Unit Testing"},{"location":"developer/automated_testing/#how-to-run-unit-tests","text":"Use the docker remote code execution 1 docker exec -it resq_app pytest or if you want to generate the coverage data 1 docker exec -it resq_app coverage run --source = \".\" --rcfile = .coveragerc -m pytest Coverage File This will produce a file called .coverage that contains the records and can be converted to reports. Allure Results Whenever you are running this tests, it will produce a folder called test_results that will contain results of the test. Refer below for more information about Allure.","title":"How to run unit tests?"},{"location":"developer/automated_testing/#how-to-get-coverage-report","text":"If you've run the tests using the above command and have .coverage file, you can generate the reports in multiple ways. More information in here . 1 coverate report -m will print the coverage report in the terminal. 1 coverage html for the html report. What is .coveragerc file? This file contains the configurations for the coverage testing.","title":"How to get coverage report?"},{"location":"developer/automated_testing/#unit-testing-in-pipelines","text":"This was part of #12 , but was cut out of scope. Some artefacts of the code can be seen here. One particular one is the docker runtime.sh that can accomodate a APP_ENV=UNIT_TESTS to only run unit tests inside the docker.","title":"Unit Testing in Pipelines"},{"location":"developer/automated_testing/#allure-report-generator","text":"Allure Testing report is used as a tool to generate test report. More information here https://docs.qameta.io/allure/ This repo has a file called send_and_generate.py . It is a simple script that sends a test report to Allure and generates a report. This is currently integrated with the UWA System Health Lab Allure Setup . Documentation can be seen here .","title":"Allure Report Generator"},{"location":"developer/automated_testing/#integration-testing","text":"The integration tests are created with Cypress . This integration testing allows us to create frontend tests and obtain video or screenshots that can improve the quality of the test.","title":"Integration Testing"},{"location":"developer/automated_testing/#running-tests-via-cypress-ide","text":"Installment Prerequisite Install Nodejs and NPM (should be automatically installed with Nodejs). Go to integration_tests folder and do npm install . That is going to install your package.json packages. In one terminal, run docker-compose up for running application. Without closing terminal opened in 1), open a new terminal and go to /integration_tests and: Run yarn run cypress:open or Run npm run cypress:open Note that by using this, the Cypress IDE will be running outside the docker container.","title":"Running Tests Via Cypress IDE"},{"location":"developer/automated_testing/#configuring-cypress","text":"Cypress configuration can be adjusted in the cypress.json file. If you want to define global varibles, this is the place to do it. Global variables can be used in the code with Cypress.env('VAR') . More information can be seen in the official docs https://docs.cypress.io/guides/references/configuration","title":"Configuring Cypress"},{"location":"developer/automated_testing/#writing-tests","text":"There are 2 ways to create tests: By writing code tests, see Writing Test Or by using the Cypress Studio Cypress studio makes it easy to create test by recording the user action through the Cypress IDE. Upon action of the user, Cypress studio writes codes in the tests which could be adjusted later for flexibility. To use Cypress Studio Test Creation Firstly, you need a test suite ends with .spec.js in the integration_tests/cypress/integration folder (either newly created from a test template or existing test). Test Template 1 2 3 4 5 6 7 8 9 describe ( 'Test Suite' , () => { beforeEach (() => { // Setup Scripts Here }) it ( 'Test Name' , () => { // Extend test with Cypress Studio }) }) Select a test suite in the Cypress IDE to extend Hover on the test, and click the \"magic wand\" icon near the test Interact with the Cypress Web interface as if you are the test runner Save the test when you are done Modify the tests created by Cypress IDE as you need Magic Wand Icon","title":"Writing Tests"},{"location":"developer/automated_testing/#test-files-and-directory-organization","text":"All test specs are located in integration_tests/cypress/integration . We recomend follow an structure by feature. In integration_tests/cypress/support you can write reusable pieces of code for execute in all your tests with commands .","title":"Test files and directory organization"},{"location":"developer/automated_testing/#test-results","text":"Results after tests suite finished are stored in the following folders: integration_tests/cypress/screenshots : Screenshots generated by cypress integration_tests/cypress/videos : Videos generated by cypress integration_tests/cypress/results : Allure formatted results","title":"Test Results"},{"location":"developer/automated_testing/#allure-integration-with-cypress","text":"Cypress test runner has installed an allure plugin which is used to generate tests results with allure format. Documentation","title":"Allure Integration with Cypress"},{"location":"developer/ci_pipeline/","text":"Continous Integration Pipeline \u00b6 These are just scripts that run whenever you do pull requests and successful merges. There are a couple of scripts that are currently configured see .github/workflows : Automated Documentation Deployment docs.yml \u00b6 This automatically deploys this documentation whenever main is updated with new changes.","title":"CI Pipeline"},{"location":"developer/ci_pipeline/#continous-integration-pipeline","text":"These are just scripts that run whenever you do pull requests and successful merges. There are a couple of scripts that are currently configured see .github/workflows :","title":"Continous Integration Pipeline"},{"location":"developer/ci_pipeline/#automated-documentation-deployment-docsyml","text":"This automatically deploys this documentation whenever main is updated with new changes.","title":"Automated Documentation Deployment docs.yml"},{"location":"developer/coding_patterns/","text":"Coding Patterns \u00b6 Casing \u00b6 This codebase will be using camel casing. Linters / Formatters \u00b6 This will automatically format your code if you install ESLint in VS Code or type yarn lint in the specific folders. Make sure you have installed the devDependencies so additional linters can be used. Github Issues and Pull Requests \u00b6 Most changes in the codebase can be matched to a github issue that contains description of the work that needs to be done. Each of the pull request are matched to this github issue with the branch name that has a standard c{Issue Number}-{branch name} . The issue number allows referencing especially when resolving reason for change. Development with Docker \u00b6 The development is done with Docker to orchestrate multiple services as defined in the docker-compose.yml file: Documentation at localhost:8001 Inconsistencies \u00b6 During the project, different developers have different terminology. Some of the inconsistencies are documented below queue means Team Name as well \u00b6 queue refers to where the student belongs to in the queue. This can either be StudySmarter or Librarian team.","title":"Coding Patterns"},{"location":"developer/coding_patterns/#coding-patterns","text":"","title":"Coding Patterns"},{"location":"developer/coding_patterns/#casing","text":"This codebase will be using camel casing.","title":"Casing"},{"location":"developer/coding_patterns/#linters-formatters","text":"This will automatically format your code if you install ESLint in VS Code or type yarn lint in the specific folders. Make sure you have installed the devDependencies so additional linters can be used.","title":"Linters / Formatters"},{"location":"developer/coding_patterns/#github-issues-and-pull-requests","text":"Most changes in the codebase can be matched to a github issue that contains description of the work that needs to be done. Each of the pull request are matched to this github issue with the branch name that has a standard c{Issue Number}-{branch name} . The issue number allows referencing especially when resolving reason for change.","title":"Github Issues and Pull Requests"},{"location":"developer/coding_patterns/#development-with-docker","text":"The development is done with Docker to orchestrate multiple services as defined in the docker-compose.yml file: Documentation at localhost:8001","title":"Development with Docker"},{"location":"developer/coding_patterns/#inconsistencies","text":"During the project, different developers have different terminology. Some of the inconsistencies are documented below","title":"Inconsistencies"},{"location":"developer/coding_patterns/#queue-means-team-name-as-well","text":"queue refers to where the student belongs to in the queue. This can either be StudySmarter or Librarian team.","title":"queue means Team Name as well"},{"location":"developer/deployment/","text":"Deployment \u00b6 The deployment of ReSQ is in the UWA Infrastructure (to be precise in the UWA System Health Lab ). The reason being is that permission is granted to Frinze Erin Lapuz (Software Team Lead of the Redbacks Team at the UWA System Health Lab). There a couple of steps that were involved in doing this: DNS Configuration \u00b6 This is a 1 time configuration The domain name is set to \"resq.systemhealthlab.com\" in UWA Cloudflare. NGINX Configuration \u00b6 Using Binchicken , I have created the NGINX configuration that will handle all requests going to the application (reverse-proxy). Nginx Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 server { server_name resq.systemhealthlab.com ; location / { proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_pass http://localhost:10023 ; proxy_set_header X-Forwarded-Proto $scheme ; proxy_http_version 1 .1 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_read_timeout 3m ; proxy_send_timeout 3m ; } listen [::]:443 ssl ; listen 443 ssl ; ssl_certificate /etc/letsencrypt/live/systemhealthlab.com/fullchain.pem ; ssl_certificate_key /etc/letsencrypt/live/systemhealthlab.com/privkey.pem ; include /etc/letsencrypt/options-ssl-nginx.conf ; ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem ; } server { listen 80 ; listen [::]:80 ; server_name resq.systemhealthlab.com www.resq.systemhealthlab.com ; return 301 https://resq.systemhealthlab.com $request_uri ; } Diagrammatic Explanation \u00b6 graph TD User -->|User goes to resq.systemhealthlab.com|Cloudflare Cloudflare-->|Sees that it is under the DNS registed on VPS|VPS subgraph UWA Infrastructure VPS -->|Configuration on Locations|NGINX NGINX -->|Host Port Location| VPS VPS --> ReSQ subgraph Docker ReSQ Other_UWA_SHL_Services end end Deployment with Docker Image \u00b6 This requires access towards the application inside the VPS. The easiest way to do this is to have access with the VPS through SSH (you may need permission for this). Once you are in there, do 1 git pull to pull in the new changes from the main branch. git pull This assumes that you already have the repository in the VPS. If it does not exist, just do git clone . Then run 1 sh deploy.sh This will rebuild all the containers (for production) as well as the new code. Gunicorn Process in Production \u00b6 The reason as to why we gunicorn process instead of flask run in production is for the main following reason: gunicorn allows parallelising of HTTP request automatic disconnect towards the database after the short-lived process (of responding to HTTP request) More information about its setup here .","title":"Deployment"},{"location":"developer/deployment/#deployment","text":"The deployment of ReSQ is in the UWA Infrastructure (to be precise in the UWA System Health Lab ). The reason being is that permission is granted to Frinze Erin Lapuz (Software Team Lead of the Redbacks Team at the UWA System Health Lab). There a couple of steps that were involved in doing this:","title":"Deployment"},{"location":"developer/deployment/#dns-configuration","text":"This is a 1 time configuration The domain name is set to \"resq.systemhealthlab.com\" in UWA Cloudflare.","title":"DNS Configuration"},{"location":"developer/deployment/#nginx-configuration","text":"Using Binchicken , I have created the NGINX configuration that will handle all requests going to the application (reverse-proxy). Nginx Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 server { server_name resq.systemhealthlab.com ; location / { proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_pass http://localhost:10023 ; proxy_set_header X-Forwarded-Proto $scheme ; proxy_http_version 1 .1 ; proxy_set_header Upgrade $http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_read_timeout 3m ; proxy_send_timeout 3m ; } listen [::]:443 ssl ; listen 443 ssl ; ssl_certificate /etc/letsencrypt/live/systemhealthlab.com/fullchain.pem ; ssl_certificate_key /etc/letsencrypt/live/systemhealthlab.com/privkey.pem ; include /etc/letsencrypt/options-ssl-nginx.conf ; ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem ; } server { listen 80 ; listen [::]:80 ; server_name resq.systemhealthlab.com www.resq.systemhealthlab.com ; return 301 https://resq.systemhealthlab.com $request_uri ; }","title":"NGINX Configuration"},{"location":"developer/deployment/#diagrammatic-explanation","text":"graph TD User -->|User goes to resq.systemhealthlab.com|Cloudflare Cloudflare-->|Sees that it is under the DNS registed on VPS|VPS subgraph UWA Infrastructure VPS -->|Configuration on Locations|NGINX NGINX -->|Host Port Location| VPS VPS --> ReSQ subgraph Docker ReSQ Other_UWA_SHL_Services end end","title":"Diagrammatic Explanation"},{"location":"developer/deployment/#deployment-with-docker-image","text":"This requires access towards the application inside the VPS. The easiest way to do this is to have access with the VPS through SSH (you may need permission for this). Once you are in there, do 1 git pull to pull in the new changes from the main branch. git pull This assumes that you already have the repository in the VPS. If it does not exist, just do git clone . Then run 1 sh deploy.sh This will rebuild all the containers (for production) as well as the new code.","title":"Deployment with Docker Image"},{"location":"developer/deployment/#gunicorn-process-in-production","text":"The reason as to why we gunicorn process instead of flask run in production is for the main following reason: gunicorn allows parallelising of HTTP request automatic disconnect towards the database after the short-lived process (of responding to HTTP request) More information about its setup here .","title":"Gunicorn Process in Production"},{"location":"developer/frontend_and_backend/","text":"Frontend and Backend Technical Documentation \u00b6 The web application can be mainly be divided into two sides: frontend or also known as client-side application, an application that runs inside the browser of the user, backend or also known as server-side application, an application that is connected with a database to facilitate data validation, transformation, and storage. The choice of a hybrid approach is deemed to be appropriate to get the best of both worlds. Client-side application with AJAX allows the user of the website to have a better user experience with minimal latency when using the application. In other words, this is also known as client-side rendering as it allows the generation of the frontend dynamically without reloading. Server-side application allows processing of the HTTP requests, but also generates a simple starting user interface before the user interacts with the application. Frontend \u00b6 The relevant files for these section can be found at app/app/static for the assets (CSS + JS) and app/app/templates for the Jinja-HTML files. Frontend Rendering \u00b6 The frontend is rendered using Jinja2 , the usual template engine for Flask. Frontend Design \u00b6 The design of the website is from Material Dashboard, a boostrap template. The documentation for it can be seen here with live demo here . This was chosen to accelerate the development of the project. Client-Side Interaction with AJAX \u00b6 AJAX allows browsers to fetch data without reloading. Essentially, makes it a better user experience. Notice the Javascript files in app/app/static/custom , these are the custom JS, and notice that each page in app/app/templates loads a particular JavaScript file. Frontend Routes \u00b6 The frontend routes are defined in routes.py . Backend \u00b6 Database \u00b6 The database is a PostgreSQL connected with the classic ORM for Flask - SQLAlchemy . With Flask-Migrate for database migration (combo of SQL Alchemy and Alembic). All the database models can be found in models.py , and database migration scripts at migrations folder. Docker Auto Migration The docker runtime.sh is configured to do auto migration. If you need to do a reverse migration, or anything very custom, Please be prepared to read the command reference . Application Programming Interface (API) \u00b6 API is where the AJAX interaction points to. The api endpoinds are defined in app/app/__init__.py . At the time of this writing, there are three main API endpoints: - queue for the main operation of digital queue - export for the exporting functionality - data for the analytics page See the individual files for more information about it. Application Configuration \u00b6 The application configuration containing database information and encryption key setups can be fond in config.py . This is just standard, nothing special or out of the ordinary.","title":"Frontend and Backend"},{"location":"developer/frontend_and_backend/#frontend-and-backend-technical-documentation","text":"The web application can be mainly be divided into two sides: frontend or also known as client-side application, an application that runs inside the browser of the user, backend or also known as server-side application, an application that is connected with a database to facilitate data validation, transformation, and storage. The choice of a hybrid approach is deemed to be appropriate to get the best of both worlds. Client-side application with AJAX allows the user of the website to have a better user experience with minimal latency when using the application. In other words, this is also known as client-side rendering as it allows the generation of the frontend dynamically without reloading. Server-side application allows processing of the HTTP requests, but also generates a simple starting user interface before the user interacts with the application.","title":"Frontend and Backend Technical Documentation"},{"location":"developer/frontend_and_backend/#frontend","text":"The relevant files for these section can be found at app/app/static for the assets (CSS + JS) and app/app/templates for the Jinja-HTML files.","title":"Frontend"},{"location":"developer/frontend_and_backend/#frontend-rendering","text":"The frontend is rendered using Jinja2 , the usual template engine for Flask.","title":"Frontend Rendering"},{"location":"developer/frontend_and_backend/#frontend-design","text":"The design of the website is from Material Dashboard, a boostrap template. The documentation for it can be seen here with live demo here . This was chosen to accelerate the development of the project.","title":"Frontend Design"},{"location":"developer/frontend_and_backend/#client-side-interaction-with-ajax","text":"AJAX allows browsers to fetch data without reloading. Essentially, makes it a better user experience. Notice the Javascript files in app/app/static/custom , these are the custom JS, and notice that each page in app/app/templates loads a particular JavaScript file.","title":"Client-Side Interaction with AJAX"},{"location":"developer/frontend_and_backend/#frontend-routes","text":"The frontend routes are defined in routes.py .","title":"Frontend Routes"},{"location":"developer/frontend_and_backend/#backend","text":"","title":"Backend"},{"location":"developer/frontend_and_backend/#database","text":"The database is a PostgreSQL connected with the classic ORM for Flask - SQLAlchemy . With Flask-Migrate for database migration (combo of SQL Alchemy and Alembic). All the database models can be found in models.py , and database migration scripts at migrations folder. Docker Auto Migration The docker runtime.sh is configured to do auto migration. If you need to do a reverse migration, or anything very custom, Please be prepared to read the command reference .","title":"Database"},{"location":"developer/frontend_and_backend/#application-programming-interface-api","text":"API is where the AJAX interaction points to. The api endpoinds are defined in app/app/__init__.py . At the time of this writing, there are three main API endpoints: - queue for the main operation of digital queue - export for the exporting functionality - data for the analytics page See the individual files for more information about it.","title":"Application Programming Interface (API)"},{"location":"developer/frontend_and_backend/#application-configuration","text":"The application configuration containing database information and encryption key setups can be fond in config.py . This is just standard, nothing special or out of the ordinary.","title":"Application Configuration"},{"location":"developer/requirements/","text":"Requirements \u00b6 Acronyms, Abbreviations and Definitions \u00b6 UWA: The University of Western Australia Tutor \u2013 The person that is providing service/help on a particular topic (eg. References, math and statistics, English) Student leader (SL) \u2013 the main point of contact of the student in need (SNS) SNS \u2013 Student in Need of Service \u2013 the person that requires help from a tutor STUDYSmarter \u2013 a service in UWA that is staffed with tutors and SNS come for help API \u2013 Application programming interface \u2013 an application that handles data requests for server-side processes Database \u2013 a place where data is stored SQL \u2013 Structured Query Language \u2013 used for building and interacting with databases HTML, CSS, JS \u2013 core web technologies that are used to build web interfaces Flask \u2013 a Python (an easy-to-use programming language) web framework that makes it easy to build APIs VPS \u2013 Virtual Private Server is a virtual machine that runs as a server within a bigger set of services Aim and Scope \u00b6 UWAs STUDYSmarter and Library teams run a daily drop-in service in the Reid Library, 10am-12 noon, where students can drop in to receive one-on-one advice on writing, research, referencing, and study skills. The service is staffed each day by two STUDYSmarter learning advisers (writing and study skills enquiries), one librarian (research and referencing) and one student leader (reception and queue management). The student leader acts as the first point of contact for the service, triaging enquiries, inputting student data, and managing the queue flow. During peak periods, demand for the service is high, and long queues can form, creating a bottleneck for the service as the student leader must manage both new and waiting clients. The ideal system would be a software program to streamline the data input/queue flow process to allow the service to operate more efficiently. Additionally, it would generate usage reports and infographics to allow STUDYSmarter to anticipate trends in usage and ensure that the service is staffed appropriately to meet demand. Requirements \u00b6 Stage 1 Functional Requirements \u00b6 The following are the core functional requirements for the first stage application Identifier Name Description S1_FR1 Login System The system should only allow SL to use the system. S1_FR2 Adding student to the queue and showing the queue The system should allow SL to add students in the queue as well as show who is currently in the queue. S1_FR3 Consuming the queue The SL should be able to assign SNS from the queue to a tutor and show the current SNS in session with a tutor. S1_FR4 Time display data For S1_FR2 and S1_FR3, the system should show how long an SNS is waiting or in session with a tutor. S1_FR5 Remove an SNS in the queue The system should allow removal of SNS in queue as per S1_FR3 or the drop-in session run out of time, and SNS needs to be removed from the queue. Stage 2 Functional Requirements \u00b6 These are the main requirements for the data usage report. It is worth noting that the stage 2 requirement is a feature block of a \u201cnice-to-have\" and will only be implemented when there is extra time in the project. Identifier Name Description S2_FR1 Collection of data usage After a session, details such as the start time, the end time are recorded for data analytics (such as aggregation, computation can be done) S2_FR2 Data usage analytics With collected data from S2_FR1, the data that is most interest is the visualisation that shows how many students use the service for different periods in the semester. S2_FR3 Daily usage report A way to send a summarised usage report for a day. S2_FR4 At-a-glance usage infographic End of each week to summarise usage/waiting times/peak usage times/comparisons to previous weeks and/or semesters \"Nice to have\" \u00b6 Some of the \"nice to haves\" of this project will be covered in this requirements documents. Howevever, \"nice to haves\" usually will come along as the users of the system see fit. This will be documented in the Issue Tracking Management sytem of the code repository. Non-functional Requirements \u00b6 Identifier Name Description NFR1 Security Only authenticated and authorised users should be able to perform actions such as adding equipment, updating equipment location and information, or searching for specific equipment. NFR2 Performance The loading time should not hinder the user experience and productivity of the user in the website. The page/actions should have a loading time < 5 seconds on most computing environments on standard internet connections** NFR3 Maintainable and extensible The website should be relatively easy to update and extended to accomodate for new contexts. NFR4 Recoverable In the event of the web server or database server crashing, all stored data should be fully recoverable. NFR5 Intuitive user interface The website should have an intuitive / easy-to-use user interface, so that users will be able to easily use the website and update the equipment database NFR6 Compatibility The application should be compatible with recent versions of the major browsers (Safari, Chrome, Firefox and Edge) on laptop and desktop computers NFR7 Deployability The application should be compatible with deployment in the SHL VPS Proposed Solution \u00b6 With the requirements and analysis of the current system, the decision of the team is to create a custom web application. The web application will be built with a MVC (Model-View-Controller) pattern using Flask (for API requests), SQL (for database solution), and Jinja Templating with core web technologies \u2013 HTML, CSS, and JavaScript (for user interface). The system will be deployed the in the UWA infrastructure. See below for the high-level solution architecture of the system. Core Technologies \u00b6 The custom web application will aim to satisfy all the requirements in here along with the \"Nice to haves\" as they come up. The application will be built using the ... API \u2013 Flask \u00b6 Flask is an easy-to-use Python web framework. This is chosen as the development team has a Python background and is the web framework used in CITS3403 \u2013 Agile Web Development. Database Solution \u2013 PostgreSQL \u00b6 SQL is a language that can be used to build and interact with database. The exact database management solution will be with PostgreSQL \u2013 a widely used and reliable database in the industry. User Interface \u2013 HTML, CSS, JS \u00b6 The core web technologies will be used for building the interfaces. No advanced framework will be used with concern to higher learning curve on top of the existing technologies being used. To aid with the design, the team will be using Bootstrap as a CSS framework to reduce the time needed for creating \u201cgood-looking\u201d and intuitive interfaces. Deployment - Docker \u00b6 Docker is a deployment technology that allows virtualization in a server to allow the packaging of software into containers for deployment. To satisfy NFR7 - Deployability, the web platform will use docker to allow the deployment through the SHL VPS Server. Furthermore, Docker will be used for orchestration of different services in development to increase speed of development, and reduce inconsistency between developers devices (NFR3 - Maintainable and extensible). Deployment will be done with docker containers in the UWA System Health Lab VPS. As part of NFR1, this deployment methodology will be within the UWA infrastructure (VPS and Cloudflare Proxy). Version and Quality Control \u00b6 The version and quality control will be facilitated using Git (a version control tool), and GitHub to facilitate peer reviewed code. Documentation - GitHub mkdocs \u00b6 The documentation will be informally made in Microsoft Word documents hosted in OneDrive. However, for future maintainability purposes, these will be uploaded to GitHub along with the source code. Code Quality \u00b6 The code quality will be ensured by peer reviews between the developers in the team. Code Storage and Development Control \u00b6 Git source control will be used, using the remote UWA System Health Lab organisational GitHub (NFR3 - Maintenace and Extensibility). Prototype \u00b6 See the Prototype mentioned in Figma Interface Prototype","title":"Requirements"},{"location":"developer/requirements/#requirements","text":"","title":"Requirements"},{"location":"developer/requirements/#acronyms-abbreviations-and-definitions","text":"UWA: The University of Western Australia Tutor \u2013 The person that is providing service/help on a particular topic (eg. References, math and statistics, English) Student leader (SL) \u2013 the main point of contact of the student in need (SNS) SNS \u2013 Student in Need of Service \u2013 the person that requires help from a tutor STUDYSmarter \u2013 a service in UWA that is staffed with tutors and SNS come for help API \u2013 Application programming interface \u2013 an application that handles data requests for server-side processes Database \u2013 a place where data is stored SQL \u2013 Structured Query Language \u2013 used for building and interacting with databases HTML, CSS, JS \u2013 core web technologies that are used to build web interfaces Flask \u2013 a Python (an easy-to-use programming language) web framework that makes it easy to build APIs VPS \u2013 Virtual Private Server is a virtual machine that runs as a server within a bigger set of services","title":"Acronyms, Abbreviations and Definitions"},{"location":"developer/requirements/#aim-and-scope","text":"UWAs STUDYSmarter and Library teams run a daily drop-in service in the Reid Library, 10am-12 noon, where students can drop in to receive one-on-one advice on writing, research, referencing, and study skills. The service is staffed each day by two STUDYSmarter learning advisers (writing and study skills enquiries), one librarian (research and referencing) and one student leader (reception and queue management). The student leader acts as the first point of contact for the service, triaging enquiries, inputting student data, and managing the queue flow. During peak periods, demand for the service is high, and long queues can form, creating a bottleneck for the service as the student leader must manage both new and waiting clients. The ideal system would be a software program to streamline the data input/queue flow process to allow the service to operate more efficiently. Additionally, it would generate usage reports and infographics to allow STUDYSmarter to anticipate trends in usage and ensure that the service is staffed appropriately to meet demand.","title":"Aim and Scope"},{"location":"developer/requirements/#requirements_1","text":"","title":"Requirements"},{"location":"developer/requirements/#stage-1-functional-requirements","text":"The following are the core functional requirements for the first stage application Identifier Name Description S1_FR1 Login System The system should only allow SL to use the system. S1_FR2 Adding student to the queue and showing the queue The system should allow SL to add students in the queue as well as show who is currently in the queue. S1_FR3 Consuming the queue The SL should be able to assign SNS from the queue to a tutor and show the current SNS in session with a tutor. S1_FR4 Time display data For S1_FR2 and S1_FR3, the system should show how long an SNS is waiting or in session with a tutor. S1_FR5 Remove an SNS in the queue The system should allow removal of SNS in queue as per S1_FR3 or the drop-in session run out of time, and SNS needs to be removed from the queue.","title":"Stage 1 Functional Requirements"},{"location":"developer/requirements/#stage-2-functional-requirements","text":"These are the main requirements for the data usage report. It is worth noting that the stage 2 requirement is a feature block of a \u201cnice-to-have\" and will only be implemented when there is extra time in the project. Identifier Name Description S2_FR1 Collection of data usage After a session, details such as the start time, the end time are recorded for data analytics (such as aggregation, computation can be done) S2_FR2 Data usage analytics With collected data from S2_FR1, the data that is most interest is the visualisation that shows how many students use the service for different periods in the semester. S2_FR3 Daily usage report A way to send a summarised usage report for a day. S2_FR4 At-a-glance usage infographic End of each week to summarise usage/waiting times/peak usage times/comparisons to previous weeks and/or semesters","title":"Stage 2 Functional Requirements"},{"location":"developer/requirements/#nice-to-have","text":"Some of the \"nice to haves\" of this project will be covered in this requirements documents. Howevever, \"nice to haves\" usually will come along as the users of the system see fit. This will be documented in the Issue Tracking Management sytem of the code repository.","title":"\"Nice to have\""},{"location":"developer/requirements/#non-functional-requirements","text":"Identifier Name Description NFR1 Security Only authenticated and authorised users should be able to perform actions such as adding equipment, updating equipment location and information, or searching for specific equipment. NFR2 Performance The loading time should not hinder the user experience and productivity of the user in the website. The page/actions should have a loading time < 5 seconds on most computing environments on standard internet connections** NFR3 Maintainable and extensible The website should be relatively easy to update and extended to accomodate for new contexts. NFR4 Recoverable In the event of the web server or database server crashing, all stored data should be fully recoverable. NFR5 Intuitive user interface The website should have an intuitive / easy-to-use user interface, so that users will be able to easily use the website and update the equipment database NFR6 Compatibility The application should be compatible with recent versions of the major browsers (Safari, Chrome, Firefox and Edge) on laptop and desktop computers NFR7 Deployability The application should be compatible with deployment in the SHL VPS","title":"Non-functional Requirements"},{"location":"developer/requirements/#proposed-solution","text":"With the requirements and analysis of the current system, the decision of the team is to create a custom web application. The web application will be built with a MVC (Model-View-Controller) pattern using Flask (for API requests), SQL (for database solution), and Jinja Templating with core web technologies \u2013 HTML, CSS, and JavaScript (for user interface). The system will be deployed the in the UWA infrastructure. See below for the high-level solution architecture of the system.","title":"Proposed Solution"},{"location":"developer/requirements/#core-technologies","text":"The custom web application will aim to satisfy all the requirements in here along with the \"Nice to haves\" as they come up. The application will be built using the ...","title":"Core Technologies"},{"location":"developer/requirements/#api-flask","text":"Flask is an easy-to-use Python web framework. This is chosen as the development team has a Python background and is the web framework used in CITS3403 \u2013 Agile Web Development.","title":"API \u2013 Flask"},{"location":"developer/requirements/#database-solution-postgresql","text":"SQL is a language that can be used to build and interact with database. The exact database management solution will be with PostgreSQL \u2013 a widely used and reliable database in the industry.","title":"Database Solution \u2013 PostgreSQL"},{"location":"developer/requirements/#user-interface-html-css-js","text":"The core web technologies will be used for building the interfaces. No advanced framework will be used with concern to higher learning curve on top of the existing technologies being used. To aid with the design, the team will be using Bootstrap as a CSS framework to reduce the time needed for creating \u201cgood-looking\u201d and intuitive interfaces.","title":"User Interface \u2013 HTML, CSS, JS"},{"location":"developer/requirements/#deployment-docker","text":"Docker is a deployment technology that allows virtualization in a server to allow the packaging of software into containers for deployment. To satisfy NFR7 - Deployability, the web platform will use docker to allow the deployment through the SHL VPS Server. Furthermore, Docker will be used for orchestration of different services in development to increase speed of development, and reduce inconsistency between developers devices (NFR3 - Maintainable and extensible). Deployment will be done with docker containers in the UWA System Health Lab VPS. As part of NFR1, this deployment methodology will be within the UWA infrastructure (VPS and Cloudflare Proxy).","title":"Deployment - Docker"},{"location":"developer/requirements/#version-and-quality-control","text":"The version and quality control will be facilitated using Git (a version control tool), and GitHub to facilitate peer reviewed code.","title":"Version and Quality Control"},{"location":"developer/requirements/#documentation-github-mkdocs","text":"The documentation will be informally made in Microsoft Word documents hosted in OneDrive. However, for future maintainability purposes, these will be uploaded to GitHub along with the source code.","title":"Documentation - GitHub mkdocs"},{"location":"developer/requirements/#code-quality","text":"The code quality will be ensured by peer reviews between the developers in the team.","title":"Code Quality"},{"location":"developer/requirements/#code-storage-and-development-control","text":"Git source control will be used, using the remote UWA System Health Lab organisational GitHub (NFR3 - Maintenace and Extensibility).","title":"Code Storage and Development Control"},{"location":"developer/requirements/#prototype","text":"See the Prototype mentioned in Figma Interface Prototype","title":"Prototype"},{"location":"user/","text":"User Documentation \u00b6 How to access the website \u00b6 Click here to redirect to the website. User will need username and password to login. There will be 3 main tabs in the website, which are Queue, Data Analytics and Export Data","title":"Overview"},{"location":"user/#user-documentation","text":"","title":"User Documentation"},{"location":"user/#how-to-access-the-website","text":"Click here to redirect to the website. User will need username and password to login. There will be 3 main tabs in the website, which are Queue, Data Analytics and Export Data","title":"How to access the website"},{"location":"user/data_analytics/","text":"Data analytics \u00b6 This website provide some basic data analytics for \"at a glance\" view. There will be 3 charts generated in the Data analytics tab: Students visited per day in the chosen week The percentages of popular units in that week Comparison between students enter STUDYSmarter and Librarian queue in that week In order to generate data analytics for a chosen week: Choose an arbitrary day in the week you want to generate data Click submit","title":"Data Analytics"},{"location":"user/data_analytics/#data-analytics","text":"This website provide some basic data analytics for \"at a glance\" view. There will be 3 charts generated in the Data analytics tab: Students visited per day in the chosen week The percentages of popular units in that week Comparison between students enter STUDYSmarter and Librarian queue in that week In order to generate data analytics for a chosen week: Choose an arbitrary day in the week you want to generate data Click submit","title":"Data analytics"},{"location":"user/export_data/","text":"Export data \u00b6 If user wants to export data to a csv file for further data analysis: Step 1: Navigate to the 'Export Data' tab Step 2: There are premade options such as \"Last week\" or \"Last Day\". You can also choose \"Custom\" option to export data between a period of your choice - Step 3: Click 'Submit', then download the file","title":"Export Data"},{"location":"user/export_data/#export-data","text":"If user wants to export data to a csv file for further data analysis: Step 1: Navigate to the 'Export Data' tab Step 2: There are premade options such as \"Last week\" or \"Last Day\". You can also choose \"Custom\" option to export data between a period of your choice - Step 3: Click 'Submit', then download the file","title":"Export data"},{"location":"user/queue/","text":"Queue \u00b6 User can manage student sessions in the Queue tab. There are 3 tables, 2 of which are STUDYSmarter queue and Librarian queue. Students will be put into either queue depending on user's choice. Staff management \u00b6 On the right side of the queue home page, you can see 2 small boxes saying \"STUDYSmarter Team Available\" and \"Librarians Available\". You can click the \"+\" and \"-\" icon to modify the number base on your current available staff. If you try to add student to the inSession queue which exceeds your current setup for each staff type, the website will give a warning alert and require you to modify the staff number. Add to queue \u00b6 In order to add a student to a waiting queue, look for the \"ADD TO QUEUE\" button in the top right corner A form will show up as below. In this form, you can enter student information and choose the queue type between \"STUDYSmarter\" and \"Librarian\" When successfully added, the student information will show up in the corresponding queue. Below is an example Managing a session \u00b6 If you want to move students from either waiting queue to \"Current Session\" table, click the green button in the \"Actions\" column If a student cancel the appointment, you can remove her/him from the waiting queue by clicking the red button in the \"Actions\" column A message box will show up and ask to confirm your action, click \"Yes\". Finish/Undo a session \u00b6 When a session is done, user can click the green button to finish the session. When user accidentally added a student to this table from waiting queue, undo it by choosing the undo button","title":"Queue"},{"location":"user/queue/#queue","text":"User can manage student sessions in the Queue tab. There are 3 tables, 2 of which are STUDYSmarter queue and Librarian queue. Students will be put into either queue depending on user's choice.","title":"Queue"},{"location":"user/queue/#staff-management","text":"On the right side of the queue home page, you can see 2 small boxes saying \"STUDYSmarter Team Available\" and \"Librarians Available\". You can click the \"+\" and \"-\" icon to modify the number base on your current available staff. If you try to add student to the inSession queue which exceeds your current setup for each staff type, the website will give a warning alert and require you to modify the staff number.","title":"Staff management"},{"location":"user/queue/#add-to-queue","text":"In order to add a student to a waiting queue, look for the \"ADD TO QUEUE\" button in the top right corner A form will show up as below. In this form, you can enter student information and choose the queue type between \"STUDYSmarter\" and \"Librarian\" When successfully added, the student information will show up in the corresponding queue. Below is an example","title":"Add to queue"},{"location":"user/queue/#managing-a-session","text":"If you want to move students from either waiting queue to \"Current Session\" table, click the green button in the \"Actions\" column If a student cancel the appointment, you can remove her/him from the waiting queue by clicking the red button in the \"Actions\" column A message box will show up and ask to confirm your action, click \"Yes\".","title":"Managing a session"},{"location":"user/queue/#finishundo-a-session","text":"When a session is done, user can click the green button to finish the session. When user accidentally added a student to this table from waiting queue, undo it by choosing the undo button","title":"Finish/Undo a session"}]}